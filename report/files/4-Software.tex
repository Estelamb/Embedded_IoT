\section{Software Organization}

\subsection{Description of the Global Software Architecture}

The Plant Monitoring System is a multi-threaded embedded application developed using the Zephyr \gls{RTOS}. It integrates multiple sensors and peripherals, manages several execution threads, uses atomic shared structures for inter-thread communication, and supports three distinct operating modes that govern its behaviour.

This section provides a unified description of system operation, the behaviour of each mode, the internal synchronization mechanisms, and the shared peripheral configuration structures.

\subsubsection{Detailed System Behaviour per Operating Mode}

The system operates according to the value of the \texttt{system\_mode\_t} enumeration, which cycles through three states: \textbf{TEST\_MODE}, \textbf{NORMAL\_MODE}, and \textbf{ADVANCED\_MODE}. The user button triggers the transitions.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{images/state_machine.png}
    \caption{System behaviour}
    \label{fig:state_machine}
\end{figure}

In \textbf{TEST\_MODE}, the system performs simple acquisition and visualisation tasks:

\begin{enumerate}
    \item The periodic measurement timer (\texttt{main\_timer}) is started with the test-mode rate (2 seconds).
    \item The sensor and \gls{GPS} threads are triggered to acquire new samples.
    \item The main thread waits for:
    \begin{itemize}
        \item \texttt{main\_sensors\_sem}: Signals completion of environmental sensor acquisition,
        \item \texttt{main\_gps\_sem}: Signals completion of \gls{GPS} sampling.
    \end{itemize}
    \item The main thread reads the shared atomic measurement structure and determines the dominant colour measured by the \gls{RGB} sensor.
    \item The \gls{RGB} \gls{LED} is set to the dominant raw channel (red, green, or blue).
    \item The measurements are displayed via the serial console.
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
    \item No limit checking, no statistics, and no warning indicators are active.
\end{enumerate}

TEST\_MODE is primarily a hardware validation mode to verify that all sensors are functional.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{images/test_mode.png}
    \caption{Test mode behaviour}
    \label{fig:test_mode}
\end{figure}

In \textbf{NORMAL\_MODE}, the system executes the full environmental monitoring workflow:

\begin{enumerate}
    \item The measurement timer is started with the normal-mode sampling rate (30 seconds).
    \item Sensor and \gls{GPS} threads acquire data and raise their semaphores.
    \item The main thread retrieves all sensor values from the atomic shared structure.
    \item Limit checking is performed for temperature, humidity, moisture, brightness, and acceleration parameters.
    \item Violations raise bits of the atomic \texttt{rgb\_flags} field, allowing multiple alarms simultaneously.
    \item A dedicated \gls{RGB} warning timer is active: at each tick it reads the \texttt{rgb\_flags} and updates the \gls{RGB} \gls{LED} with colour-coded warnings.
    \item The system maintains statistical data, which is shown every hour:
    \begin{itemize}
        \item running minimum and maximum,
        \item running mean values,
        \item colour frequency counts.
    \end{itemize}
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
\end{enumerate}

NORMAL\_MODE is the complete monitoring and alert mode.

\begin{figure}[H]
    \centering
    %\includegraphics[width=0.99\textwidth]{images/normal_mode.png}
    \caption{Normal mode behaviour}
    \label{fig:normal_mode}
\end{figure}

In \textbf{ADVANCED\_MODE}, the system focuses on reproducing the sensed colour with high fidelity:

\begin{enumerate}
    \item The measurement timer is started with the advanced-mode sampling rate (30 seconds).
    \item Sensor and \gls{GPS} threads acquire data and raise their semaphores.
    \item The main thread retrieves all sensor values from the atomic shared structure.
    \item Colour normalization is performed using the clear channel of the colour sensor, and shown.
    \item The \gls{RGB} \gls{LED} is set to the normalized colour values for accurate reproduction (emulated PWM).
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
    \item No limit checking, no statistics, and no warning indicators are active.
\end{enumerate}

ADVANCED\_MODE is a pure high-resolution colour rendering mode.

\begin{figure}[H]
    \centering
    %\includegraphics[width=0.99\textwidth]{images/advanced_mode.png}
    \caption{Advanced mode behaviour}
    \label{fig:advanced_mode}
\end{figure}


\subsubsection{Mode Transition Mechanism}

The user button controls mode transitions. The button interrupt triggers a deferred work handler, ensuring transitions occur in thread context. The mode progression is cyclic:

\[
\texttt{TEST\_MODE} \rightarrow \texttt{NORMAL\_MODE} \rightarrow \texttt{ADVANCED\_MODE} \rightarrow \texttt{TEST\_MODE}
\]

During a mode change:

\begin{itemize}
    \item timers associated with the previous mode are stopped,
    \item mode-specific timers are started (measurement, \gls{RGB} warning, statistics),
    \item \glspl{LED} are updated to reflect the new mode,
    \item \texttt{main\_sem} is released to unblock the main loop.
\end{itemize}

\subsubsection{Semaphore Synchronisation and Thread Interactions}

Inter-thread coordination relies on multiple named semaphores.

\begin{itemize}
    \item \textbf{Measurement Timer Semaphore (\texttt{main\_sem})}
    
    Released by \texttt{main\_timer} to:

    \begin{itemize}
        \item Wake the main thread at the configured sampling frequency to repeat the mode.
        \item Wake the main thread when a mode transition occurs (button pressed).
    \end{itemize}

    \item \textbf{Trigger Semaphores (\texttt{sensors\_sem} and \texttt{gps\_sem})}

    These semaphores are released by \texttt{main\_timer} to notify the respective threads to begin their measurement cycles.

    \item \textbf{Sensor Data Semaphore (\texttt{main\_sensors\_sem})}

    Raised by the sensor acquisition thread after reading:

    \begin{itemize}
        \item Temperature and humidity.
        \item \gls{RGB} colour channels.
        \item Brightness.
        \item Soil moisture.
        \item Accelerometer values.
    \end{itemize}

    The main thread blocks until this semaphore is obtained, ensuring consistent data.

    \item \textbf{\gls{GPS} Data Semaphore (\texttt{main\_gps\_sem})}

    Raised by the \gls{GPS} thread when new \gls{GPS} information (latitude, longitude, altitude, satellites, timestamp) is available.

    The main thread blocks until this semaphore is obtained, ensuring consistent data.
\end{itemize}

Together, these semaphores serialise measurement flow and guarantee no partial or inconsistent samples.

\subsubsection{Atomic Shared Measurement Structure}

Sensor data is stored in a global structure using only atomic variables:

\begin{lstlisting}[language=C, caption={Sensor data structure with atomic fields}]
struct system_measurement {
    atomic_t brightness;  /**< Latest ambient brightness (0-100%). */
    atomic_t moisture;    /**< Latest soil moisture (0-100%). */

    atomic_t accel_x_g;   /**< Latest X-axis acceleration (in g). */
    atomic_t accel_y_g;   /**< Latest Y-axis acceleration (in g). */
    atomic_t accel_z_g;   /**< Latest Z-axis acceleration (in g). */

    atomic_t temp;        /**< Latest temperature (C). */
    atomic_t hum;         /**< Latest relative humidity (%RH). */

    atomic_t red;         /**< Latest red color value (raw). */
    atomic_t green;       /**< Latest green color value (raw). */
    atomic_t blue;        /**< Latest blue color value (raw). */
    atomic_t clear;       /**< Latest clear color channel value (raw). */

    atomic_t gps_lat;     /**< Latest GPS latitude (degrees). */
    atomic_t gps_lon;     /**< Latest GPS longitude (degrees). */
    atomic_t gps_alt;     /**< Latest GPS altitude (meters). */
    atomic_t gps_sats;    /**< Latest number of satellites in view. */
    atomic_t gps_time;    /**< Latest GPS timestamp (float or encoded). */
};
\end{lstlisting}

Properties:

\begin{itemize}
    \item Lock-free thread-safe communication.
    \item Each measurement updated independently.
    \item the main thread reads all values without risk of torn writes.
\end{itemize}

\subsubsection{Peripheral Configuration Structure}

All peripherals and synchronisation objects are referenced through a single shared structure:

\begin{lstlisting}[language=C, caption={Peripheral configuration and synchronization structure}]
struct system_context {
    struct adc_config *phototransistor; /**< Phototransistor ADC configuration. */
    struct adc_config *soil_moisture;   /**< Soil moisture ADC configuration. */

    struct i2c_dt_spec *accelerometer;  /**< Accelerometer I2C device specification. */
    uint8_t accel_range;                /**< Accelerometer full-scale range (e.g., 2G, 4G, 8G). */

    struct i2c_dt_spec *temp_hum;       /**< Temperature and humidity sensor I2C specification. */
    struct i2c_dt_spec *color;          /**< Color sensor I2C device specification. */
    struct gps_config *gps;             /**< GPS module configuration. */

    struct k_sem *main_sensors_sem;     /**< Semaphore for main-to-sensors synchronization. */
    struct k_sem *main_gps_sem;         /**< Semaphore for main-to-GPS synchronization. */
    struct k_sem *sensors_sem;          /**< Semaphore to trigger sensor measurement. */
    struct k_sem *gps_sem;              /**< Semaphore to trigger GPS measurement. */
};
\end{lstlisting}

In this way, the peripherals are configured once at startup and passed to all threads and modules that require access.

\subsubsection{Secure Initialization}

In case of initialization failures (e.g., \gls{I2C} device not found), the system doesn't execute the program:

\begin{lstlisting}[language=C, caption={Secure initialization code}]
    /* Initialize peripherals */
    if (gps_init(&gps)) {
        printk("GPS initialization failed - Program stopped\n");
        return -1;
    }
    if (adc_init(&pt)) {
        printk("Phototransistor initialization failed - Program stopped\n");
        return -1;
    }
    if (adc_init(&sm)) {
        printk("Soil moisture sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (accel_init(&accel, ACCEL_RANGE)) {
        printk("Accelerometer initialization failed - Program stopped\n");
        return -1;
    }
    if (temp_hum_init(&th, TEMP_HUM_RESOLUTION)) {
        printk("Temperature/Humidity sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (color_init(&color, COLOR_GAIN, COLOR_INTEGRATION_TIME)) {
        printk("Color sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (led_init(&leds) || led_off(&leds)) {
        printk("LED initialization failed - Program stopped\n");
        return -1;
    }
    if (rgb_led_init(&rgb_leds) || rgb_led_off(&rgb_leds)) {
        printk("RGB LED initialization failed - Program stopped\n");
        return -1;
    }
    if (button_init(&button))  {
        printk("Button initialization failed - Program stopped\n");
        return -1;
    }
    if (button_set_callback(&button, button_isr)) {
        printk("Button callback setup failed - Program stopped\n");
        return -1;
    }

\end{lstlisting} \todo{Añadir captura}

\subsubsection{Device Disconnected}

In case one device is disconnected during operation, an error message is printed, but the program continues running. It shows the last valid measurement for that sensor.

\todo{Añadir captura}

If the device is reconnected, normal operation resumes.

\todo{Añadir captura}


\subsection{Modules}

\subsubsection{adc.c and adc.h}

The \texttt{adc.c} and \texttt{adc.h} modules provide a hardware abstraction layer for reading analogue values from the phototransistor and soil-moisture sensors using the Zephyr \gls{ADC} \gls{API}. Their purpose is to encapsulate \gls{ADC} initialisation, configuration, and acquisition into a self-contained interface that the sensors thread can use without exposing low-level driver details.

This library is responsible for preparing the \gls{ADC} peripheral, configuring its channels, and performing synchronous conversions on demand. It ensures that all \gls{ADC} reads comply with a consistent configuration (resolution, reference, acquisition time, and oversampling) and that raw sample values are returned in a unified format to the rest of the system.

\begin{itemize}
    \item \textbf{Peripheral Initialisation}: Loads the \gls{ADC} device from the device tree and configures the hardware according to project requirements. This includes selecting resolution, reference voltage, acquisition time, and optional oversampling.

    \item \textbf{Channel Setup}: Each analogue sensor has an associated \gls{ADC} channel configured through a dedicated structure. The module ensures correct pin routing and channel mapping according to the board overlay.

    \item \textbf{Synchronous ADC Sampling}: Provides a blocking \gls{API} that triggers a single conversion and returns the measured sample. This prevents concurrency issues by guaranteeing that read operations finish before returning control.

    \item \textbf{Unified Abstraction for Higher-Level Modules}: The sensors thread and the system context only interact with a clean, high-level interface without needing to manage \gls{ADC} device handles, channels, or Zephyr-specific configuration fields.

    \item \textbf{Validation and Error Handling}: Detects device-not-found conditions, invalid configurations, or read failures, forwarding errors to the main system so that appropriate recovery or safe behaviour can occur.

    \item \textbf{Scalability for Additional Channels}: The design allows new analogue sensors to be added by defining a new channel configuration and calling the same acquisition \gls{API}, without modifying existing code.
    
    \item \textbf{Separation of Configuration from Logic}: The module centralises all \gls{ADC} configuration parameters in one place, ensuring future modifications (e.g., resolution, gain, sampling frequency) do not propagate across the project.
\end{itemize}

This \gls{ADC} library is intended to be reused by any component that requires analogue-to-digital conversions while maintaining a clean separation between hardware-specific details and system-level functionality.

\subsubsection{gps.c and gps.h}

The \texttt{gps.c} and \texttt{gps.h} modules implement a GPS interface based on \gls{UART}-driven reception of \gls{NMEA} sentences. Their purpose is to offer a simple, self-contained parser for \gls{GGA} (or \gls{GNGGA}) frames and provide the rest of the system with clean, validated geographic data without exposing \gls{UART} or interrupt logic.

The library configures the \gls{UART} peripheral, enables interrupt-driven reception, reconstructs \gls{NMEA} lines in the background, and parses the relevant fields when a complete \gls{GGA} sentence is detected. Once valid GPS information is available, the module updates an internal \texttt{gps\_data\_t} structure and releases a semaphore so that higher-level threads can safely retrieve the most recent fix.

\begin{itemize}
    \item \textbf{\gls{UART}-Based \gls{GPS} Initialisation}: The module validates the configuration, checks device readiness, attaches the \gls{ISR}, and enables \gls{RX} interrupts. This ensures autonomous background reception of \gls{NMEA} data.

    \item \textbf{Interrupt-Driven \gls{NMEA} Line Reconstruction}: Bytes received from the \gls{UART} \gls{FIFO} are accumulated into an internal buffer until a newline character is found.

    \item \textbf{\gls{GGA} Sentence Parsing}: Extracts latitude, longitude, altitude, \gls{HDOP}, satellite count, and \gls{UTC} time from a standard \gls{GGA} frame. The parser handles missing or malformed fields gracefully and only accepts complete, coherent entries.

    \item \textbf{\gls{NMEA}-to-Degrees Conversion}: Converts coordinates from \gls{NMEA} format (DDMM.MMMM or DDDMM.MMMM) to decimal degrees, applying hemisphere correction. This provides the system with immediately usable geographic values.

    \item \textbf{Thread Synchronisation via Semaphore}: When new valid data is parsed, a semaphore is released so that the \gls{GPS} thread or main thread can block until a fresh fix is available. This avoids polling and reduces \gls{CPU} usage.

    \item \textbf{Internal Data Buffering}: The module maintains an internal instance of \texttt{gps\_data\_t} storing the last valid parsed frame. Consumers obtain a copy, ensuring thread safety without exposing shared mutable structures.

    \item \textbf{Timeout-Aware Data Retrieval}: The high-level \gls{API} allows callers to wait indefinitely, for a fixed period, or return immediately if no new \gls{GGA} sentence has been received.
\end{itemize}

This \gls{GPS} interface provides a robust and maintainable foundation for acquiring geographic data in real time, isolating UART management and parsing details from the rest of the application.

\subsubsection{i2c.c and i2c.h}

The \texttt{i2c.c} and \texttt{i2c.h} modules implement a small set of helper functions designed to simplify register-level communication with \gls{I2C} devices in Zephyr. Their purpose is to provide a clean, reusable interface for reading and writing device registers using only a devicetree \texttt{i2c\_dt\_spec}, avoiding repetitive low-level code in sensor drivers.

The library encapsulates common \gls{I2C} access patterns into concise functions. These utilities internally rely on Zephyr's \texttt{i2c\_write\_read\_dt}, \texttt{i2c\_write\_dt}, and \texttt{i2c\_is\_ready\_dt} \glspl{API}, ensuring compatibility with any \gls{I2C} peripheral described in the system devicetree.

Because many sensors require register-based configuration and multi-byte reads, this module centralises these operations and presents a uniform interface that higher-level modules can reuse safely.

\begin{itemize}
    \item \textbf{Multi-Register Read Helper}: Reads an arbitrary number of consecutive registers starting at a given address, abstracting the common write-then-read transaction pattern.

    \item \textbf{Single-Register Write Helper}: Writes one byte to a specified register, a frequent requirement for sensor configuration and control registers.

    \item \textbf{Device Readiness Check}: Verifies that the \gls{I2C} device is present, powered, and ready before attempting communication. Provides clear error reporting if the device is not reachable.

    \item \textbf{Consistent Devicetree-Based Access}: All functions operate on \texttt{i2c\_dt\_spec} descriptors, ensuring that pin routing, bus selection, addressing and timing come directly from the devicetree.

    \item \textbf{Reusability for Multiple Sensor Drivers}: Higher-level modules (accelerometer, colour sensor, temperature/humidity sensor, etc.) use these helpers to avoid code duplication and maintain consistency across all \gls{I2C} devices.
    
    \item \textbf{Error Propagation}: Returns standard negative errno codes, allowing calling modules to handle failures predictably and implement fallback or retry mechanisms.
\end{itemize}

This \gls{I2C} helper library provides a clean and robust foundation for register-based communication with any \gls{I2C} sensor or peripheral in the system.

\subsubsection{accel.c and accel.h}

The \texttt{accel.c} and \texttt{accel.h} modules implement a 3-axis accelerometer driver over \gls{I2C}, providing initialization, configuration, raw data acquisition, and unit conversion utilities. The module abstracts all register-level interaction and exposes a clean interface for obtaining acceleration data in either raw counts, g units, or m/s².

During initialization, the library verifies device identity via the \texttt{WHO\_AM\_I} register, transitions the sensor into standby mode, configures its measurement range, and finally activates continuous measurement mode. The project uses the ±2g range, which maximizes sensitivity for environmental and motion-tracking applications.

Raw acceleration values for X, Y, and Z axes are obtained through a single burst read of six consecutive registers. This ensures atomic acquisition of all three axes and prevents axis desynchronization. Each pair of bytes contains a 14-bit left-aligned signed measurement, which the library re-aligns before returning to higher-level modules.

All \gls{I2C} communication relies on the generic register helpers defined in the \gls{I2C} module, keeping the driver compact and uniform with the rest of the system.

\begin{itemize}
    \item \textbf{Device Initialization and Identity Check}: Reads the \texttt{WHO\_AM\_I} register to validate the sensor's presence before configuration or data acquisition.

    \item \textbf{Standby and Active Mode Control}: Ensures that configuration registers are only modified while the device is in standby mode, as required by the hardware design. The module automatically returns the device to active mode after configuration.

    \item \textbf{Measurement Range Configuration}: Supports ±2g, ±4g, and ±8g ranges via the \texttt{XYZ\_DATA\_CFG} register. The system uses ±2g for improved resolution and noise performance. \todo{chequear gs del acelerometro}

    \item \textbf{Burst Read of 6 Output Registers}: Performs a single multi-register transaction to retrieve X, Y, and Z values consistently, minimizing communication overhead and avoiding partial updates.

    \item \textbf{Raw Data Alignment and Extraction}: Converts the sensor's 14-bit left-aligned format into signed 14-bit integers usable by higher-level modules.

    \item \textbf{Conversion to g Units}: Applies sensitivity scaling based on the configured range, providing a convenient floating-point representation.

    \item \textbf{Conversion to m/s²}: Converts from g units to SI units using standard gravity, enabling direct use in physical calculations or movement detection algorithms.
\end{itemize}

This accelerometer module provides a robust basis for motion sensing, offering clean abstractions for configuration, raw acquisition, and physical-unit conversion while preserving full compatibility with the system's \gls{I2C} infrastructure.

\subsubsection{color.c and color.h}



\subsubsection{temp\_hum.c and temp\_hum.h}

\subsubsection{board\_led.c and board\_led.h}

\subsubsection{rgb\_led.c and rgb\_led.h}

\subsubsection{user\_button.c and user\_button.h}


\subsection{Threads}

\subsubsection{Main Thread}

\subsubsection{Sensors Thread}

\subsubsection{\acrshort{GPS} Thread}




\subsection{Zephyr \acrshort{RTOS}} \todo{chequear en todo el docuemnto si zephyr es os o rtos} \todo{añadir texto}

\subsubsection{prj\_nucleo\_wl55jc.conf}

\begin{lstlisting}
    CONFIG_STDOUT_CONSOLE=y
    CONFIG_UART_CONSOLE=y
    CONFIG_CONSOLE=y
    CONFIG_PRINTK=y
    CONFIG_CBPRINTF_FP_SUPPORT=y
    CONFIG_POLL=y

    CONFIG_EVENTS=y
    CONFIG_LOG=y

    CONFIG_GPIO=y # Enable GPIO

    CONFIG_ADC=y  # Enable ADC

    CONFIG_I2C=y  # Enable I2C

    CONFIG_SERIAL=y
    CONFIG_UART_INTERRUPT_DRIVEN=y # Enable UART interrupt-driven API

    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y
\end{lstlisting}

\subsubsection{nucleo\_wl55jc.overlay}

\begin{lstlisting}
    #include <zephyr/dt-bindings/pinctrl/stm32-pinctrl.h>

    / {
        rgb_leds {
            compatible = "gpio-leds";

            rgb_red: rgb_0 {
                gpios = <&gpioa 6 GPIO_ACTIVE_LOW>;
                label = "Red RGB LED";
            };
            rgb_green: rgb_1 {
                gpios = <&gpioa 7 GPIO_ACTIVE_LOW>;
                label = "Green RGB LED";
            };
            rgb_blue: rgb_2 {
                gpios = <&gpioa 9 GPIO_ACTIVE_LOW>;
                label = "Blue RGB LED";
            };
        };

        aliases {
            red = &rgb_red;
            green = &rgb_green;
            blue = &rgb_blue;
            led0 = &blue_led_1; 	// This is LED1 as labeled STM32WL55JC board's 
    		led1 = &green_led_2; 	// This is LED2 as labeled STM32WL55JC board's 
    		led2 = &red_led_3; 	    // This is LED3 as labeled STM32WL55JC board's 
        };


    };

    &usart1 {
        status = "okay";
        current-speed = <9600>;
        pinctrl-0 = <&usart1_tx_pb6 &usart1_rx_pb7>;
        pinctrl-names = "default";
    };

\end{lstlisting}


\subsection{Thread Stack and \acrshort{CPU} Usage Analysis}

Zephyr provides runtime diagnostics that allow monitoring of the stack usage and \gls{CPU} load of each thread in the system. The output shown in the image presents detailed information for all active threads, including their stack consumption, remaining free stack space, and the total number of \gls{CPU} cycles executed since startup.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/stack.png}
    \caption{Thread stack and \gls{CPU} usage}
    \label{fig:stack}
\end{figure}

It is important to understand the purpose of each thread displayed:

\begin{itemize}
    \item \textbf{gps\_thread:} Thread responsible for configuring, reading and parsing \gls{GPS} data.

    \item \textbf{sensors\_thread:} Thread responsible for sensor readings (accelerometer, colour sensor, etc.).

    \item \textbf{thread\_analyzer:} Internal diagnostic thread used to collect and report thread metrics such as stack usage. It runs periodically and only consumes \gls{CPU} during short analysis windows.

    \item \textbf{sysworkq:} The global Zephyr system workqueue. It is used to run small background tasks that do not need their own dedicated thread. Typical examples include executing callbacks.  

    \item \textbf{logging:} Internal Zephyr thread in charge of processing log messages.

    \item \textbf{idle:} Lowest-priority thread that runs whenever no other thread is ready. It accounts for the majority of \gls{CPU} cycles, which is expected and desirable in a low-power sensor system.

    \item \textbf{main:} The initial thread created at system startup.

    \item \textbf{\gls{ISR}0 (\gls{ISR} stack):} Not a regular thread, but the shared stack region used by all interrupt service routines.
\end{itemize}

For each thread, the following metrics are displayed:

\begin{itemize}
    \item \textbf{STACK:} Reports the unused stack space, the amount of stack used, and the total allocated stack size.  
    For example, for \texttt{gps\_thread}:
    \[
    \text{unused } 768 \text{ B},\quad \text{used } 256 \text{ B},\quad \text{total } 1024 \text{ B}
    \]
    This corresponds to a stack usage of 25\%, indicating that the assigned memory is sufficient and no overflow risk is present. 

    As a general guideline, \textbf{stack usage below 60\% is considered safe} in Zephyr, as it leaves enough headroom for context switching, interrupts, and occasional peak loads.

    \item \textbf{\gls{CPU}:} Shows the percentage of \gls{CPU} time consumed by each thread.  
    Most application threads such as \texttt{gps\_thread} or \texttt{sensors\_thread} show 0\% \gls{CPU} usage because they predominantly sleep while waiting for periodic timers or I/O events.

    \item \textbf{Total \gls{CPU} cycles used:} Indicates the cumulative processor cycles consumed by each thread since boot.  
    
    Threads like \texttt{idle} present extremely large values, which is expected since the idle thread runs whenever no other thread is ready to execute. A high idle count is a positive indicator of energy efficiency.
\end{itemize}

This is obtained thanks to the following configuration options enabled in \texttt{prj\_nucleo\_wl55jc.conf}, which allow Zephyr to track stack usage, assign human-readable thread names, and automatically generate periodic thread analysis reports:

\begin{lstlisting}[caption={Thread stack and CPU usage report - prj\_nucleo\_wl55jc.conf}]
    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y    
\end{lstlisting}

Overall, the reported values confirm that:

\begin{itemize}
    \item All thread stacks remain within safe usage ranges, with most below the recommended 60\% threshold.
    \item \gls{CPU} usage distribution behaves as expected for a sensor-driven, event-based embedded application.
    \item The idle thread dominates \gls{CPU} cycles, indicating efficient low-power execution and minimal background processing overhead.
\end{itemize}



\subsection{Compilation and Flashing Output Analysis}

During the compilation process, Zephyr generates a memory usage summary that indicates how much Flash and \gls{RAM} the final application occupies. As shown in \autoref{fig:build}, after linking the executable \texttt{zephyr.elf}, the memory report provides the following information:

\begin{itemize}
    \item \textbf{FLASH:} 59.024B used out of 256KB (approximately 22.5\%).
    \item \textbf{\gls{RAM}:} 13.504B used out of 64KB (approximately 20.6\%).
\end{itemize}

This confirms that the firmware comfortably fits within the memory limits of the STM32WL55 microcontroller, leaving sufficient headroom for future improvements or additional functionality.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/build.png}
    \caption{Compilation memory usage report}
    \label{fig:build}
\end{figure}

\subsection{Flashing the Firmware onto the STM32WL55}

The \autoref{fig:flash} corresponds to the flashing process performed using \texttt{STM32CubeProgrammer}, which communicates with the NUCLEO-WL55JC board via the onboard ST-LINK debugger. The tool successfully identifies the target device, displaying key details such as:

\begin{itemize}
    \item \textbf{Device:} STM32WLxx.
    \item \textbf{Flash Size:} 256KB.
    \item \textbf{Core:} \gls{ARM} Cortex-M4.
    \item \textbf{Supply Voltage:} 3.28V.
    \item \textbf{Connection Mode:} Under Reset.
\end{itemize}

After loading the generated \texttt{zephyr.hex} file (57.64KB), the programmer performs the following steps:

\begin{enumerate}
    \item Erases the internal Flash sectors (0 to 28).
    \item Programs the firmware at address \texttt{0x08000000}.
    \item Verifies the integrity of the written data.
    \item Starts the application.
\end{enumerate}

The final message, \textit{``Application is running, Please Hold on...''}, indicates that the microcontroller has successfully been programmed and is now executing the uploaded Zephyr firmware.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/flash.png}
    \caption{Flashing process using STM32CubeProgrammer}
    \label{fig:flash}
\end{figure}

\subsection{Code Documentation}

The project documentation is generated automatically through a continuous integration workflow implemented using a GitHub Action (\autoref{ap:github}). This workflow executes the Doxygen engine, which extracts structured information directly from the annotated comments within the source code. By following Doxygen's documentation conventions, each module, function, and data structure is described where it is implemented, ensuring that the documentation remains consistent with the evolving codebase.

Whenever new commits are pushed to the repository, the GitHub Action is triggered, automatically regenerating the documentation and preventing discrepancies between the implementation and its technical description. As part of the same workflow, the generated documentation is automatically deployed to a GitHub Pages site, making it accessible online without requiring manual intervention.

The documentation can be accessed directly through the following link: \url{https://estelamb.github.io/Embedded_IoT/}.
