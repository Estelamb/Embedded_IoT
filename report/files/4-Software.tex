\section{Software Organization}

\subsection{Description of the Global Software Architecture}

The Plant Monitoring System is a multi-threaded embedded application developed using the Zephyr RTOS. It integrates multiple sensors and peripherals, manages several execution threads, uses atomic shared structures for inter-thread communication, and supports three distinct operating modes that govern its behaviour.

This section provides a unified description of system operation, the behaviour of each mode, the internal synchronization mechanisms, and the shared peripheral configuration structures.

\subsubsection{Detailed System Behaviour per Operating Mode}

The system operates according to the value of the \texttt{system\_mode\_t} enumeration, which cycles through three states: \textbf{TEST\_MODE}, \textbf{NORMAL\_MODE}, and \textbf{ADVANCED\_MODE}. The user button triggers the transitions.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{images/state_machine.png}
    \caption{System behaviour}
    \label{fig:state_machine}
\end{figure}

In \textbf{TEST\_MODE}, the system performs simple acquisition and visualisation tasks:

\begin{enumerate}
    \item The periodic measurement timer (\texttt{main\_timer}) is started with the test-mode rate (2 seconds).
    \item The sensor and GPS threads are triggered to acquire new samples.
    \item The main thread waits for:
    \begin{itemize}
        \item \texttt{main\_sensors\_sem} --- signals completion of environmental sensor acquisition,
        \item \texttt{main\_gps\_sem} --- signals completion of GPS sampling.
    \end{itemize}
    \item The main thread reads the shared atomic measurement structure and determines the dominant colour measured by the RGB sensor.
    \item The RGB LED is set to the dominant raw channel (red, green, or blue).
    \item The measurements are displayed via the serial console.
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
    \item No limit checking, no statistics, and no warning indicators are active.
\end{enumerate}

TEST\_MODE is primarily a hardware validation mode to verify that all sensors are functional.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{images/test_mode.png}
    \caption{Test mode behaviour}
    \label{fig:test_mode}
\end{figure}

In \textbf{NORMAL\_MODE}, the system executes the full environmental monitoring workflow:

\begin{enumerate}
    \item The measurement timer is started with the normal-mode sampling rate (30 seconds).
    \item Sensor and GPS threads acquire data and raise their semaphores.
    \item The main thread retrieves all sensor values from the atomic shared structure.
    \item Limit checking is performed for temperature, humidity, moisture, brightness, and acceleration parameters.
    \item Violations raise bits of the atomic \texttt{rgb\_flags} field, allowing multiple alarms simultaneously.
    \item A dedicated RGB warning timer is active: at each tick it reads the \texttt{rgb\_flags} and updates the RGB LED with colour-coded warnings.
    \item The system maintains statistical data, which is shown every hour:
    \begin{itemize}
        \item running minimum and maximum,
        \item running mean values,
        \item colour frequency counts.
    \end{itemize}
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
\end{enumerate}

NORMAL\_MODE is the complete monitoring and alert mode.

\begin{figure}[H]
    \centering
    %\includegraphics[width=0.99\textwidth]{images/normal_mode.png}
    \caption{Normal mode behaviour}
    \label{fig:normal_mode}
\end{figure}

In \textbf{ADVANCED\_MODE}, the system focuses on reproducing the sensed colour with high fidelity:

\begin{enumerate}
    \item The measurement timer is started with the advanced-mode sampling rate (30 seconds).
    \item Sensor and GPS threads acquire data and raise their semaphores.
    \item The main thread retrieves all sensor values from the atomic shared structure.
    \item Colour normalization is performed using the clear channel of the colour sensor, and shown.
    \item The RGB LED is set to the normalized colour values for accurate reproduction (emulated PWM).
    \item At each timer expiration, the \texttt{main\_sem} semaphore is released to repeat the mode.
    \item No limit checking, no statistics, and no warning indicators are active.
\end{enumerate}

ADVANCED\_MODE is a pure high-resolution colour rendering mode.

\begin{figure}[H]
    \centering
    %\includegraphics[width=0.99\textwidth]{images/advanced_mode.png}
    \caption{Advanced mode behaviour}
    \label{fig:advanced_mode}
\end{figure}


\subsubsection{Mode Transition Mechanism}

The user button controls mode transitions. The button interrupt triggers a deferred work handler, ensuring transitions occur in thread context. The mode progression is cyclic:

\[
\texttt{TEST\_MODE} \rightarrow \texttt{NORMAL\_MODE} \rightarrow \texttt{ADVANCED\_MODE} \rightarrow \texttt{TEST\_MODE}
\]

During a mode change:

\begin{itemize}
    \item timers associated with the previous mode are stopped,
    \item mode-specific timers are started (measurement, RGB warning, statistics),
    \item LEDs are updated to reflect the new mode,
    \item \texttt{main\_sem} is released to unblock the main loop.
\end{itemize}

\subsubsection{Semaphore Synchronisation and Thread Interactions}

Inter-thread coordination relies on multiple named semaphores.

\begin{itemize}
    \item \textbf{Measurement Timer Semaphore (\texttt{main\_sem})}
    
    Released by \texttt{main\_timer} to:

    \begin{itemize}
        \item wake the main thread at the configured sampling frequency to repeat the mode.
        \item wake the main thread when a mode transition occurs (button pressed).
    \end{itemize}

    \item \textbf{Trigger Semaphores (\texttt{sensors\_sem} and \texttt{gps\_sem})}

    These semaphores are released by \texttt{main\_timer} to notify the respective threads to begin their measurement cycles.

    \item \textbf{Sensor Data Semaphore (\texttt{main\_sensors\_sem})}

    Raised by the sensor acquisition thread after reading:

    \begin{itemize}
        \item temperature and humidity,
        \item RGB colour channels,
        \item brightness,
        \item soil moisture,
        \item accelerometer values.
    \end{itemize}

    The main thread blocks until this semaphore is obtained, ensuring consistent data.

    \item \textbf{GPS Data Semaphore (\texttt{main\_gps\_sem})}

    Raised by the GPS thread when new GPS information (latitude, longitude, altitude, satellites, timestamp) is available.

    The main thread blocks until this semaphore is obtained, ensuring consistent data.
\end{itemize}

Together, these semaphores serialise measurement flow and guarantee no partial or inconsistent samples.

\subsubsection{Atomic Shared Measurement Structure}

Sensor data is stored in a global structure using only atomic variables:

\begin{lstlisting}[language=C, caption={Sensor data structure with atomic fields}]
struct system_measurement {
    atomic_t brightness;  /**< Latest ambient brightness (0-100%). */
    atomic_t moisture;    /**< Latest soil moisture (0-100%). */

    atomic_t accel_x_g;   /**< Latest X-axis acceleration (in g). */
    atomic_t accel_y_g;   /**< Latest Y-axis acceleration (in g). */
    atomic_t accel_z_g;   /**< Latest Z-axis acceleration (in g). */

    atomic_t temp;        /**< Latest temperature (C). */
    atomic_t hum;         /**< Latest relative humidity (%RH). */

    atomic_t red;         /**< Latest red color value (raw). */
    atomic_t green;       /**< Latest green color value (raw). */
    atomic_t blue;        /**< Latest blue color value (raw). */
    atomic_t clear;       /**< Latest clear color channel value (raw). */

    atomic_t gps_lat;     /**< Latest GPS latitude (degrees). */
    atomic_t gps_lon;     /**< Latest GPS longitude (degrees). */
    atomic_t gps_alt;     /**< Latest GPS altitude (meters). */
    atomic_t gps_sats;    /**< Latest number of satellites in view. */
    atomic_t gps_time;    /**< Latest GPS timestamp (float or encoded). */
};
\end{lstlisting}

Properties:

\begin{itemize}
    \item \textbf{lock-free thread-safe communication},
    \item \textbf{each measurement updated independently},
    \item the main thread reads all values without risk of torn writes.
\end{itemize}

\subsubsection{Peripheral Configuration Structure}

All peripherals and synchronisation objects are referenced through a single shared structure:

\begin{lstlisting}[language=C, caption={Peripheral configuration and synchronization structure}]
struct system_context {
    struct adc_config *phototransistor; /**< Phototransistor ADC configuration. */
    struct adc_config *soil_moisture;   /**< Soil moisture ADC configuration. */

    struct i2c_dt_spec *accelerometer;  /**< Accelerometer I2C device specification. */
    uint8_t accel_range;                /**< Accelerometer full-scale range (e.g., 2G, 4G, 8G). */

    struct i2c_dt_spec *temp_hum;       /**< Temperature and humidity sensor I2C specification. */
    struct i2c_dt_spec *color;          /**< Color sensor I2C device specification. */
    struct gps_config *gps;             /**< GPS module configuration. */

    struct k_sem *main_sensors_sem;     /**< Semaphore for main-to-sensors synchronization. */
    struct k_sem *main_gps_sem;         /**< Semaphore for main-to-GPS synchronization. */
    struct k_sem *sensors_sem;          /**< Semaphore to trigger sensor measurement. */
    struct k_sem *gps_sem;              /**< Semaphore to trigger GPS measurement. */
};
\end{lstlisting}

\subsubsection{Secure Initialization}

In case of initialization failures (e.g., I2C device not found), the system doesn't execute the program:

\begin{lstlisting}[language=C, caption={Secure initialization code}]
    /* Initialize peripherals */
    if (gps_init(&gps)) {
        printk("GPS initialization failed - Program stopped\n");
        return -1;
    }
    if (adc_init(&pt)) {
        printk("Phototransistor initialization failed - Program stopped\n");
        return -1;
    }
    if (adc_init(&sm)) {
        printk("Soil moisture sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (accel_init(&accel, ACCEL_RANGE)) {
        printk("Accelerometer initialization failed - Program stopped\n");
        return -1;
    }
    if (temp_hum_init(&th, TEMP_HUM_RESOLUTION)) {
        printk("Temperature/Humidity sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (color_init(&color, COLOR_GAIN, COLOR_INTEGRATION_TIME)) {
        printk("Color sensor initialization failed - Program stopped\n");
        return -1;
    }
    if (led_init(&leds) || led_off(&leds)) {
        printk("LED initialization failed - Program stopped\n");
        return -1;
    }
    if (rgb_led_init(&rgb_leds) || rgb_led_off(&rgb_leds)) {
        printk("RGB LED initialization failed - Program stopped\n");
        return -1;
    }
    if (button_init(&button))  {
        printk("Button initialization failed - Program stopped\n");
        return -1;
    }
    if (button_set_callback(&button, button_isr)) {
        printk("Button callback setup failed - Program stopped\n");
        return -1;
    }

\end{lstlisting} \todo{A単adir captura}

\subsubsection{Device Disconnected}

In case one device is disconnected during operation, an error message is printed, but the program continues running. It shows the last valid measurement for that sensor.

\todo{A単adir captura}

If the device is reconnected, normal operation resumes.

\todo{A単adir captura}


\subsection{Modules}

\subsubsection{adc.c and adc.h}

\subsubsection{gps.c and gps.h}

\subsubsection{i2c.c and i2c.h}

\subsubsection{accel.c and accel.h}

\subsubsection{color.c and color.h}

\subsubsection{temp\_hum.c and temp\_hum.h}

\subsubsection{board\_led.c and board\_led.h}

\subsubsection{rgb\_led.c and rgb\_led.h}

\subsubsection{user\_button.c and user\_button.h}


\subsection{Threads}

\subsubsection{Main Thread}

\subsubsection{Sensors Thread}

\subsubsection{\acrshort{GPS} Thread}




\subsection{Zephyr \acrshort{RTOS}} \todo{chequear en todo el docuemnto si zephyr es os o rtos} \todo{a単adir texto}

\subsubsection{prj\_nucleo\_wl55jc.conf}

\begin{lstlisting}
    CONFIG_STDOUT_CONSOLE=y
    CONFIG_UART_CONSOLE=y
    CONFIG_CONSOLE=y
    CONFIG_PRINTK=y
    CONFIG_CBPRINTF_FP_SUPPORT=y
    CONFIG_POLL=y

    CONFIG_EVENTS=y
    CONFIG_LOG=y

    CONFIG_GPIO=y # Enable GPIO

    CONFIG_ADC=y  # Enable ADC

    CONFIG_I2C=y  # Enable I2C

    CONFIG_SERIAL=y
    CONFIG_UART_INTERRUPT_DRIVEN=y # Enable UART interrupt-driven API

    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y
\end{lstlisting}

\subsubsection{nucleo\_wl55jc.overlay}

\begin{lstlisting}
    #include <zephyr/dt-bindings/pinctrl/stm32-pinctrl.h>

    / {
        rgb_leds {
            compatible = "gpio-leds";

            rgb_red: rgb_0 {
                gpios = <&gpioa 6 GPIO_ACTIVE_LOW>;
                label = "Red RGB LED";
            };
            rgb_green: rgb_1 {
                gpios = <&gpioa 7 GPIO_ACTIVE_LOW>;
                label = "Green RGB LED";
            };
            rgb_blue: rgb_2 {
                gpios = <&gpioa 9 GPIO_ACTIVE_LOW>;
                label = "Blue RGB LED";
            };
        };

        aliases {
            red = &rgb_red;
            green = &rgb_green;
            blue = &rgb_blue;
            led0 = &blue_led_1; 	// This is LED1 as labeled STM32WL55JC board's 
    		led1 = &green_led_2; 	// This is LED2 as labeled STM32WL55JC board's 
    		led2 = &red_led_3; 	    // This is LED3 as labeled STM32WL55JC board's 
        };


    };

    &usart1 {
        status = "okay";
        current-speed = <9600>;
        pinctrl-0 = <&usart1_tx_pb6 &usart1_rx_pb7>;
        pinctrl-names = "default";
    };

\end{lstlisting}


\subsection{Thread Stack and CPU Usage Analysis}

Zephyr provides runtime diagnostics that allow monitoring of the stack usage and CPU load of each thread in the system. The output shown in the image presents detailed information for all active threads, including their stack consumption, remaining free stack space, and the total number of CPU cycles executed since startup.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/stack.png}
    \caption{Thread stack and \gls{CPU} usage}
    \label{fig:stack}
\end{figure}

It is important to understand the purpose of each thread displayed:

\begin{itemize}
    \item \textbf{gps\_thread:} Thread responsible for configuring, reading and parsing GPS data.

    \item \textbf{sensors\_thread:} Thread responsible for sensor readings (accelerometer, colour sensor, etc.).

    \item \textbf{thread\_analyzer:} Internal diagnostic thread used to collect and report thread metrics such as stack usage. It runs periodically and only consumes CPU during short analysis windows.

    \item \textbf{sysworkq:} The global Zephyr system workqueue. It is used to run small background tasks that do not need their own dedicated thread. Typical examples include executing callbacks.  

    \item \textbf{logging:} Internal Zephyr thread in charge of processing log messages.

    \item \textbf{idle:} Lowest-priority thread that runs whenever no other thread is ready. It accounts for the majority of CPU cycles, which is expected and desirable in a low-power sensor system.

    \item \textbf{main:} The initial thread created at system startup.

    \item \textbf{ISR0 (ISR stack):} Not a regular thread, but the shared stack region used by all interrupt service routines.
\end{itemize}

For each thread, the following metrics are displayed:

\begin{itemize}
    \item \textbf{STACK:} Reports the unused stack space, the amount of stack used, and the total allocated stack size.  
    For example, for \texttt{gps\_thread}:
    \[
    \text{unused } 768 \text{ B},\quad \text{used } 256 \text{ B},\quad \text{total } 1024 \text{ B}
    \]
    This corresponds to a stack usage of 25\%, indicating that the assigned memory is sufficient and no overflow risk is present. 

    As a general guideline, \textbf{stack usage below 60\% is considered safe} in Zephyr, as it leaves enough headroom for context switching, interrupts, and occasional peak loads.

    \item \textbf{CPU:} Shows the percentage of CPU time consumed by each thread.  
    Most application threads such as \texttt{gps\_thread} or \texttt{sensors\_thread} show 0\% CPU usage because they predominantly sleep while waiting for periodic timers or I/O events.

    \item \textbf{Total CPU cycles used:} Indicates the cumulative processor cycles consumed by each thread since boot.  
    
    Threads like \texttt{idle} present extremely large values, which is expected since the idle thread runs whenever no other thread is ready to execute. A high idle count is a positive indicator of energy efficiency.
\end{itemize}

This is obtained thanks to the following configuration options enabled in
\texttt{prj\_nucleo\_wl55jc.conf}, which allow Zephyr to track stack usage,
assign human-readable thread names, and automatically generate periodic
thread analysis reports:

\begin{lstlisting}[caption={Thread stack and CPU usage report - prj\_nucleo\_wl55jc.conf}]
    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y    
\end{lstlisting}

Overall, the reported values confirm that:

\begin{itemize}
    \item All thread stacks remain within safe usage ranges, with most below the recommended 60\% threshold.
    \item CPU usage distribution behaves as expected for a sensor-driven, event-based embedded application.
    \item The idle thread dominates CPU cycles, indicating efficient low-power execution and minimal background processing overhead.
\end{itemize}



\subsection{Compilation and Flashing Output Analysis}

During the compilation process, Zephyr generates a memory usage summary that indicates how much Flash and RAM the final application occupies. As shown in \autoref{fig:build}, after linking the executable \texttt{zephyr.elf}, the memory report provides the following information:

\begin{itemize}
    \item \textbf{FLASH:} 59.024B used out of 256KB (approximately 22.5\%).
    \item \textbf{RAM:} 13.504B used out of 64KB (approximately 20.6\%).
\end{itemize}

This confirms that the firmware comfortably fits within the memory limits of the STM32WL55 microcontroller, leaving sufficient headroom for future improvements or additional functionality.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/build.png}
    \caption{Compilation memory usage report}
    \label{fig:build}
\end{figure}

\subsection{Flashing the Firmware onto the STM32WL55}

The \autoref{fig:flash} corresponds to the flashing process performed using \texttt{STM32CubeProgrammer}, which communicates with the NUCLEO-WL55JC board via the onboard ST-LINK debugger. The tool successfully identifies the target device, displaying key details such as:

\begin{itemize}
    \item \textbf{Device:} STM32WLxx.
    \item \textbf{Flash Size:} 256\,KB.
    \item \textbf{Core:} ARM Cortex-M4.
    \item \textbf{Supply Voltage:} 3.28\,V.
    \item \textbf{Connection Mode:} Under Reset.
\end{itemize}

After loading the generated \texttt{zephyr.hex} file (57.64\,KB), the programmer performs the following steps:

\begin{enumerate}
    \item Erases the internal Flash sectors (0 to 28).
    \item Programs the firmware at address \texttt{0x08000000}.
    \item Verifies the integrity of the written data.
    \item Starts the application.
\end{enumerate}

The final message, \textit{``Application is running, Please Hold on...''}, indicates that the microcontroller has successfully been programmed and is now executing the uploaded Zephyr firmware.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/flash.png}
    \caption{Flashing process using STM32CubeProgrammer}
    \label{fig:flash}
\end{figure}

\subsection{Code Documentation}

The project documentation is generated automatically through a continuous integration workflow implemented using a GitHub Action (\autoref{ap:github}). This workflow executes the Doxygen engine, which extracts structured information directly from the annotated comments within the source code. By following Doxygen's documentation conventions, each module, function, and data structure is described where it is implemented, ensuring that the documentation remains consistent with the evolving codebase.

Whenever new commits are pushed to the repository, the GitHub Action is triggered, automatically regenerating the documentation and preventing discrepancies between the implementation and its technical description. As part of the same workflow, the generated documentation is automatically deployed to a GitHub Pages site, making it accessible online without requiring manual intervention.

The documentation can be accessed directly through the following link: \url{https://estelamb.github.io/Embedded_IoT/}.
